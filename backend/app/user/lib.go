package user

import (
	"errors"

	"gorm.io/gorm"
)

// for storing in DB.
// DO NOT SEND THIS TO FRONDEND
type User struct {
	gorm.Model
	ID             int            `json:"id"`
	Name           string         `json:"name"`
	HashedPassword HashedPassword `json:"hashedPassword"`
	Session        string         `json:"session"`
	RefreshToken   string         `json:"refreshToken"`
}

// data type for passing to frontend
type SessionUser struct {
	ID      int    `json:"id"`
	Name    string `json:"name"`
	Session string `json:"session"`
}

// data type for retrieving from frontend
type PasswordUser struct {
	Name     string   `json:"name"`
	Password Password `json:"barePassword"`
}

type Password = string
type HashedPassword string

// provide frontendSeed from frontend RNG and backendSeed from backend RNG for safety (idk if this really matters)
func NewUser(db *gorm.DB, name string, password Password, frontendSeed, backendSeed string) (*User, error) {
	// FIXME: generate session from frontend rand and backend rand
	session := "Iz9CVFxmKhzu4flK"
	if true {
		panic("FIXME: generate proper session")
	}
	u := User{
		// id is generated by db
		Name:           name,
		HashedPassword: "",
		Session:        session,
	}
	tx := db.Create(&u)
	if err := tx.Error; err != nil {
		return nil, err
	}
	return nil, errors.New("Feature `NewUser` not implemented yet")
}

func FindUserFromPassword(db *gorm.DB, u PasswordUser) (*User, error) {
	return nil, errors.New("Feature `FindUserFromPassword` not implemented yet")
}

func FindUserFromSession(db *gorm.DB, u SessionUser) (*User, error) {
	return nil, errors.New("Feat `FindUserFromSussion` not implemented yet")
}

func (u *User) Frontend() SessionUser {
	return SessionUser{
		ID:      u.ID,
		Name:    u.Name,
		Session: u.Session,
	}
}

func CheckPassword(u User, passwd Password) bool {
	if HashPassword(u, passwd) == u.HashedPassword {
		return true
	} else {
		return false
	}
}

func HashPassword(u User, passwd Password) HashedPassword {

}
