package user

import (
	"errors"

	"github.com/ut-code/JourniCal/backend/pkg/hash"
	"github.com/ut-code/JourniCal/backend/pkg/random"
	"golang.org/x/oauth2"
	"gorm.io/gorm"
	"time"
)

// for storing in DB.
type User struct {
	gorm.Model
	ID             uint           `json:"id"`
	Username       string         `json:"name"`
	HashedPassword HashedPassword `json:"-"`
	Salt           string         `json:"-"`
	Session        string         `json:"session"`
	AccessToken    string         `json:"-"`
	TokenType      string         `json:"-"`
	RefreshToken   string         `json:"-"`
	TokenExpiry    time.Time      `json:"-"`
}

// data type for passing to/from frontend
type SessionUser struct {
	ID       uint   `json:"id"`
	Username string `json:"name"`
	Session  string `json:"session"`
}

type Password = string
type HashedPassword string

// provide frontendSeed from frontend RNG and backendSeed from backend RNG for safety (idk if this really matters)
// provide token with nil to skip token initialization
// provide db with nil to skip saving to db
func CreateUser(db *gorm.DB, username string, password Password, frontendSeed, backendSeed string, token *oauth2.Token) (*User, error) {
	var err error
	us := []User{}
	if db == nil {
		goto regen_session
	}
	err = db.Where("username = ?", username).Find(&us).Error
	if err != nil {
		return nil, err
	}
	if len(us) >= 1 {
		return nil, errors.New("user of same username already there")
	}
regen_session:
	session := hash.SHA256(frontendSeed, backendSeed).Hex()
	salt := random.String(32)
	if token == nil {
		token = &oauth2.Token{}
	}
	err = db.Where("session = ?", session).Find(&us).Error
	if err != nil {
		return nil, err
	}
	if len(us) >= 1 {
		// same session is not allowed
		backendSeed = random.String(32)
		goto regen_session
	}
	u := User{
		// id is generated by db
		Username:       username,
		HashedPassword: "",
		Session:        session,
		Salt:           salt,
		AccessToken:    token.AccessToken,
		TokenType:      token.TokenType,
		RefreshToken:   token.RefreshToken,
		TokenExpiry:    token.Expiry,
	}
	u.HashedPassword = HashPassword(username, password, salt)
	if db == nil {
		return &u, nil
	}
	tx := db.Create(&u)
	if err := tx.Error; err != nil {
		return nil, err
	}
	return &u, nil
}

func FindUserFromPassword(db *gorm.DB, username string, password Password) (*User, error) {
	// use advanced querying: SELECT salt FROM ...
	// read https://gorm.io/ja_JP/docs/advanced_query.html for more.
	var findSalt = struct {
		Salt string
	}{}
	err := db.Model(&User{}).Where("username = ?", username).Find(&findSalt).Error
	if err != nil {
		return nil, err
	}
	if findSalt.Salt == "" {
		return nil, errors.New("user not found in find salt step")
	}
	var dest = []User{}
	hashedPassword := HashPassword(username, password, findSalt.Salt)
	err = db.Where("username = ?", username).Where("hashed_password = ?", hashedPassword).Find(&dest).Error
	if err != nil {
		return nil, err
	}
	if len(dest) == 0 {
		return nil, errors.New("user matching the username and password not found")
	}
	if len(dest) > 1 {
		return nil, errors.New("more than 2 Users matching the and password found")
	}
	return &dest[0], err
}

func FindUserFromSession(db *gorm.DB, u SessionUser) (*User, error) {
	var dest User
	err := db.Where("id = ?", u.ID).Where("username = ?", u.Username).Where("session = ?", u.Session).Find(&dest).Error
	return &dest, err
}

func (u *User) Update(newUsername string, password Password) {
	panic("user.Update() not implemented yet")
}

func (u *User) SessionUser() SessionUser {
	return SessionUser{
		ID:       u.ID,
		Username: u.Username,
		Session:  u.Session,
	}
}

func CheckPassword(u User, passwd Password) bool {
	if HashPassword(u.Username, passwd, u.Salt) == u.HashedPassword {
		return true
	} else {
		return false
	}
}

func HashPassword(username string, passwd Password, salt string) HashedPassword {
	v := hash.SHA256(username, passwd, salt)
	return HashedPassword(v.Hex())
}
